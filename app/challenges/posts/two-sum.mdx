---
title: "Two Sum"
slug: "two-sum"
platform: "LeetCode"
difficulty: 2
languages: ["Go", "TypeScript"]
tags: ["array", "hash-map", "algorithms"]
sourceUrl: "https://leetcode.com/problems/two-sum/"
date: "2025-12-25"
summary: "Encontrar dois n√∫meros em um array que somam um valor alvo espec√≠fico."
thumbnail: "/thumbnails/two-sum.jpg"
---

## üß© Problema

Dado um array de inteiros `nums` e um inteiro `target`, retorne os **√≠ndices** dos dois n√∫meros que somam o valor `target`.

Voc√™ pode assumir que cada entrada tem **exatamente uma solu√ß√£o**, e voc√™ n√£o pode usar o mesmo elemento duas vezes.

Voc√™ pode retornar a resposta em qualquer ordem.

**Exemplo 1:**
```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explica√ß√£o: nums[0] + nums[1] = 2 + 7 = 9
```

**Exemplo 2:**
```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

**Exemplo 3:**
```
Input: nums = [3,3], target = 6
Output: [0,1]
```

**Restri√ß√µes:**
- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- Apenas uma resposta v√°lida existe

---

## üí° Abordagem

### Solu√ß√£o Ing√™nua (For√ßa Bruta)

A abordagem mais simples seria verificar todos os pares poss√≠veis usando dois loops aninhados. Para cada elemento, verificar√≠amos se existe outro elemento que soma ao target. Esta solu√ß√£o tem complexidade O(n¬≤).

### Solu√ß√£o Otimizada (Hash Map)

Podemos resolver este problema em uma √∫nica passagem usando um **hash map** (ou dicion√°rio):

1. **Ideia principal:** Para cada n√∫mero `num` no array, verificamos se o complemento `target - num` j√° foi visto anteriormente
2. **Estrutura de dados:** Usamos um hash map para armazenar os n√∫meros j√° vistos e seus √≠ndices
3. **Algoritmo:**
   - Iteramos pelo array uma vez
   - Para cada elemento, calculamos o complemento necess√°rio
   - Se o complemento j√° est√° no hash map, encontramos a solu√ß√£o
   - Caso contr√°rio, adicionamos o n√∫mero atual ao hash map

**Por que Hash Map?**
- Busca em O(1) em m√©dia
- Armazenamento do √≠ndice junto com o valor
- Evita a necessidade de loops aninhados

---

## üß™ Solu√ß√£o

### Solu√ß√£o em Go

```go
func twoSum(nums []int, target int) []int {
    // Hash map para armazenar valor -> √≠ndice
    seen := make(map[int]int)

    for i, num := range nums {
        complement := target - num

        // Verificar se o complemento j√° foi visto
        if idx, found := seen[complement]; found {
            return []int{idx, i}
        }

        // Armazenar o n√∫mero atual e seu √≠ndice
        seen[num] = i
    }

    // N√£o deveria chegar aqui dado que h√° garantia de solu√ß√£o
    return nil
}
```

### Solu√ß√£o em TypeScript

```typescript
function twoSum(nums: number[], target: number): number[] {
    const seen = new Map<number, number>();

    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];

        // Verificar se o complemento j√° foi visto
        if (seen.has(complement)) {
            return [seen.get(complement)!, i];
        }

        // Armazenar o n√∫mero atual e seu √≠ndice
        seen.set(nums[i], i);
    }

    // N√£o deveria chegar aqui dado que h√° garantia de solu√ß√£o
    return [];
}
```

---

## ‚è±Ô∏è Complexidade

**Complexidade de Tempo:** `O(n)`
- Percorremos o array **uma √∫nica vez**
- Cada opera√ß√£o de busca e inser√ß√£o no hash map √© O(1) em m√©dia
- Onde n √© o tamanho do array

**Complexidade de Espa√ßo:** `O(n)`
- No pior caso, armazenamos n-1 elementos no hash map
- Quando a solu√ß√£o est√° nos dois √∫ltimos elementos do array

---

## üîó Refer√™ncias

- [Two Sum - LeetCode](https://leetcode.com/problems/two-sum/)
- [Go Maps in Action](https://go.dev/blog/maps)
- [TypeScript Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)

---

## üìù Notas Adicionais

### Armadilhas Comuns

1. **Usar o mesmo elemento duas vezes:** O problema especifica que n√£o podemos usar o mesmo **√≠ndice** duas vezes, mas podemos ter valores duplicados no array
2. **Ordenar o array:** N√£o ordene o array! Isso mudaria os √≠ndices originais
3. **Retornar valores em vez de √≠ndices:** O problema pede os **√≠ndices**, n√£o os valores

### Varia√ß√µes do Problema

- **Two Sum II:** Array j√° ordenado (permite usar two pointers)
- **3Sum:** Encontrar tr√™s n√∫meros que somam zero
- **4Sum:** Encontrar quatro n√∫meros que somam um target
- **Two Sum - Input array is sorted:** Permite otimiza√ß√£o com two pointers sem hash map

### Curiosidades

Este √© um dos problemas mais populares do LeetCode e frequentemente aparece em entrevistas t√©cnicas. √â excelente para:
- Demonstrar conhecimento de hash maps
- Mostrar habilidade de otimiza√ß√£o (de O(n¬≤) para O(n))
- Praticar trade-off entre tempo e espa√ßo
