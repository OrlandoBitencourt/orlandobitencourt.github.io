---
title: "Claude Sub-Agents: Como parei de conversar com IA e comecei a delegar trabalho"
publishedAt: "2026-01-03"
summary: "Sub-agents n√£o s√£o prompts especializados - s√£o contratos de responsabilidade. Aprenda a arquitetar um sistema de agentes especializados no Claude Code que transformam sua produtividade."
thumbnail: "/thumbnails/claude-subagents.jpg"
tags: [Claude, AI, Produtividade, Arquitetura, Best Practices]
---

## TL;DR

Depois de meses usando Claude Code, percebi que a maioria das pessoas usa IA como um chat glorificado. A virada de chave acontece quando voc√™ para de **conversar** e come√ßa a **delegar**. Sub-agents s√£o a forma de fazer isso de forma estruturada.

**O que s√£o:** Agentes especializados com responsabilidades bem definidas, invocados via `/` no Claude Code.

**Por que usar:** Consist√™ncia, qualidade e contexto limpo. Cada agente √© expert em uma coisa e roda em seu pr√≥prio contexto.

**O ganho oculto:** Seu contexto principal n√£o satura. Sub-agents rodam isolados, preservando a "mem√≥ria de trabalho" da conversa principal.

**Resultado:** Code reviews melhores, documenta√ß√£o consistente, conversas mais longas sem degrada√ß√£o, e menos retrabalho.

*Tempo de leitura: ~20 minutos.*

---

## A evolu√ß√£o: chat ‚Üí prompt ‚Üí agente ‚Üí sub-agent

Quando comecei a usar IA para programa√ß√£o, minha intera√ß√£o era assim:

```markdown
- Eu: "Me ajuda a fazer um endpoint de login"
- IA: *gera c√≥digo gen√©rico*
___
- Eu: "N√£o, precisa ter rate limiting"
- IA: *refaz*
___
- Eu: "Esqueceu o logging"
- IA: *refaz de novo*
```

Isso √© usar IA como um estagi√°rio confuso que precisa de microgerenciamento constante.

A pr√≥xima fase foi criar prompts melhores - instru√ß√µes mais detalhadas, contexto mais rico. Funcionava melhor, mas ainda era uma conversa de ida e volta.

Agentes foram o pr√≥ximo salto. Um agente tem:
- **Goal**: O que ele precisa alcan√ßar
- **Context**: Informa√ß√µes que ele precisa saber
- **Constraints**: Limites do que ele pode/deve fazer
- **Tools**: O que ele tem dispon√≠vel para usar

Mas quando voc√™ tem m√∫ltiplas responsabilidades diferentes, um agente √∫nico vira um monstro cheio de instru√ß√µes conflitantes. √â a√≠ que entram os **sub-agents**.

<MermaidDiagram
  title="Evolu√ß√£o do Uso de IA: Do Chat aos Sub-Agents"
  chart={`
flowchart LR
    subgraph Chat[Chat B√°sico]
        C1[Pergunta] --> C2[Resposta]
        C2 --> C3[Corre√ß√£o]
        C3 --> C4[Nova corre√ß√£o]
    end

    subgraph Prompt[Prompt Engineering]
        P1[Prompt detalhado] --> P2[Resposta melhor]
        P2 --> P3[Ajuste fino]
    end

    subgraph Agent[Agente √önico]
        A1[Goal + Context] --> A2[Execu√ß√£o]
        A2 --> A3[Resultado]
    end

    subgraph SubAgents[Sub-Agents]
        S1[Orquestrador] --> S2[Code Reviewer]
        S1 --> S3[Security Auditor]
        S1 --> S4[Doc Writer]
        S2 --> S5[Resultado Integrado]
        S3 --> S5
        S4 --> S5
    end

    Chat -->|Evolu√ß√£o| Prompt
    Prompt -->|Evolu√ß√£o| Agent
    Agent -->|Evolu√ß√£o| SubAgents

    style Chat fill:#7f1d1d,stroke:#ef4444,color:#fee2e2
    style Prompt fill:#78350f,stroke:#f59e0b,color:#fef3c7
    style Agent fill:#1e3a8a,stroke:#3b82f6,color:#dbeafe
    style SubAgents fill:#14532d,stroke:#22c55e,color:#dcfce7
  `}
/>

## O que s√£o sub-agents no Claude Code

Sub-agents s√£o agentes especializados que voc√™ pode invocar dentro do Claude Code usando o comando `/`. Cada um tem uma responsabilidade √∫nica e bem definida.

A analogia que funciona pra mim: pense em um time de engenharia. Voc√™ n√£o pede pro mesmo dev fazer code review, escrever documenta√ß√£o, otimizar performance E configurar infra. Voc√™ tem especialistas.

Sub-agents s√£o esses especialistas. O `code-reviewer` s√≥ faz review. O `doc-writer` s√≥ escreve docs. O `security-auditor` s√≥ analisa seguran√ßa.

<ExecutableCode
  title="Invoking Sub-Agents in Claude Code"
  language="bash"
  code={`# Focused code review
/code-reviewer analyze file payment_processor.go

# Security analysis
/security-auditor check vulnerabilities in auth module

# Documentation generation
/doc-writer create ADR for Redis cache decision

# Go specialist
/golang-expert optimize ProcessBatch function to reduce allocations`}
  output={`‚úì code-reviewer: Analyzing payment_processor.go...
  ‚Üí 3 issues found (1 critical, 2 suggestions)

‚úì security-auditor: Scanning auth module...
  ‚Üí 1 medium vulnerability found (CWE-287)

‚úì doc-writer: Generating ADR...
  ‚Üí ADR-0015-redis-cache.md created

‚úì golang-expert: Optimizing ProcessBatch...
  ‚Üí 40% reduction in allocations suggested`}
/>

A m√°gica n√£o est√° na tecnologia, est√° na **separa√ß√£o de responsabilidades**. Cada agente pode ter instru√ß√µes espec√≠ficas, exemplos espec√≠ficos, e constraints espec√≠ficas para seu dom√≠nio.

## Quick Start: Seu primeiro sub-agent em 5 minutos

Quer testar agora antes de continuar lendo? Fa√ßa isso:

<ExecutableCode
  title="Instant Setup"
  language="bash"
  code={`# 1. Create agents folder
mkdir -p ~/.claude

# 2. Create your first agent
cat > ~/.claude/code-reviewer.md << 'EOF'
# Code Reviewer

## Role
You are a senior code reviewer.

## Focus
- Obvious bugs
- Error handling
- Poor naming
- Untreated edge cases

## Output Format
| Severity | Line | Issue | Suggestion |
|----------|------|-------|------------|
| üî¥/üü°/üü¢  | N    | ...   | ...        |

## Example
| Severity | Line | Issue | Suggestion |
|----------|------|-------|------------|
| üî¥ Critical | 42 | Error ignored | Add err check |
EOF

echo "‚úÖ Agent created!"

# 3. Test it now!
# Open Claude Code and type:
# /code-reviewer analyze [your file]`}
  output={`‚úÖ Folder ~/.claude/ created
‚úÖ Agent code-reviewer.md saved
‚úÖ Available via /code-reviewer

üöÄ Ready to use! Go back to Claude Code and test:
   /code-reviewer analyze src/main.go`}
/>

**Funcionou?** √ìtimo! Agora continue lendo para entender como isso funciona e como criar agentes mais sofisticados.

**N√£o funcionou?** Verifique:
- O arquivo est√° em `~/.claude/code-reviewer.md` (caminho absoluto)
- O arquivo tem extens√£o `.md`
- Claude Code est√° aberto (reinicie se necess√°rio)

## O ganho oculto: preserva√ß√£o de contexto

Aqui est√° algo que pouca gente fala, mas que faz uma diferen√ßa enorme na pr√°tica: **sub-agents rodam em contextos isolados**.

### O problema do contexto saturado

Toda conversa com IA tem um limite de contexto (a "janela" de tokens que ela consegue processar). Quando voc√™ usa um √∫nico agente para tudo, cada intera√ß√£o consome parte desse contexto:

<MermaidDiagram
  title="Problema: Contexto Saturado em Agente √önico"
  chart={`
flowchart TB
    subgraph Context[Contexto Principal - 200K tokens]
        direction TB
        I1[System Prompt<br/>5K tokens]
        I2[C√≥digo do projeto<br/>50K tokens]
        I3[Hist√≥rico de chat<br/>30K tokens]
        I4[Code review anterior<br/>20K tokens]
        I5[An√°lise de seguran√ßa<br/>25K tokens]
        I6[Docs geradas<br/>15K tokens]
        I7[Mais c√≥digo<br/>40K tokens]
        I8[‚ö†Ô∏è Espa√ßo restante<br/>15K tokens]
    end

    style I8 fill:#7f1d1d,stroke:#ef4444,color:#fee2e2
    style Context fill:#1e293b,stroke:#64748b,color:#e2e8f0
  `}
/>

Conforme a conversa avan√ßa, o contexto vai enchendo. Quando atinge o limite:
- A IA come√ßa a "esquecer" partes antigas da conversa
- Respostas ficam menos precisas
- Voc√™ precisa repetir contexto que j√° deu antes
- Eventualmente precisa come√ßar uma conversa nova

### A solu√ß√£o: contextos isolados

Com sub-agents, cada agente roda em seu pr√≥prio contexto. O contexto principal s√≥ guarda o essencial: o resultado final de cada sub-agent, n√£o todo o processo.

<MermaidDiagram
  title="Solu√ß√£o: Contextos Isolados com Sub-Agents"
  chart={`
flowchart TB
    subgraph Main[Contexto Principal - 200K tokens]
        direction TB
        M1[System Prompt<br/>5K tokens]
        M2[C√≥digo do projeto<br/>50K tokens]
        M3[Hist√≥rico resumido<br/>10K tokens]
        M4[‚úÖ Resultado: code-review<br/>2K tokens]
        M5[‚úÖ Resultado: security<br/>1K tokens]
        M6[‚úÖ Resultado: docs<br/>3K tokens]
        M7[üü¢ Espa√ßo dispon√≠vel<br/>129K tokens]
    end

    subgraph Sub1[Sub-Agent: Code Reviewer]
        S1A[Instru√ß√µes espec√≠ficas]
        S1B[C√≥digo em an√°lise]
        S1C[An√°lise detalhada]
        S1D[Output estruturado]
    end

    subgraph Sub2[Sub-Agent: Security Auditor]
        S2A[Instru√ß√µes de seguran√ßa]
        S2B[C√≥digo vulner√°vel]
        S2C[An√°lise OWASP]
        S2D[Findings formatados]
    end

    subgraph Sub3[Sub-Agent: Doc Writer]
        S3A[Templates de docs]
        S3B[Contexto t√©cnico]
        S3C[Gera√ß√£o de ADR]
        S3D[Documento final]
    end

    Sub1 -->|Apenas resultado| M4
    Sub2 -->|Apenas resultado| M5
    Sub3 -->|Apenas resultado| M6

    style M7 fill:#14532d,stroke:#22c55e,color:#dcfce7
    style Main fill:#1e293b,stroke:#64748b,color:#e2e8f0
    style Sub1 fill:#1e3a8a,stroke:#3b82f6,color:#dbeafe
    style Sub2 fill:#581c87,stroke:#a855f7,color:#e9d5ff
    style Sub3 fill:#78350f,stroke:#f59e0b,color:#fef3c7
  `}
/>

### Impacto real na pr√°tica

<ComparisonTable
  title="Comparativo: Agente √önico vs Sub-Agents"
  columns={[
    { header: "Aspecto", key: "aspect" },
    { header: "Agente √önico", key: "single", align: "center" },
    { header: "Sub-Agents", key: "multi", align: "center" },
  ]}
  data={[
    {
      aspect: "Uso de contexto por tarefa",
      single: "100% acumulativo",
      multi: "Isolado por agente",
      highlight: true,
    },
    {
      aspect: "Dura√ß√£o √∫til da conversa",
      single: "~30-50 intera√ß√µes",
      multi: "~200+ intera√ß√µes",
      highlight: true,
    },
    {
      aspect: "Degrada√ß√£o de qualidade",
      single: "Progressiva",
      multi: "M√≠nima",
    },
    {
      aspect: "Necessidade de repetir contexto",
      single: "Frequente",
      multi: "Rara",
    },
    {
      aspect: "Precis√£o em tarefas espec√≠ficas",
      single: "M√©dia (instru√ß√µes dilu√≠das)",
      multi: "Alta (instru√ß√µes focadas)",
      highlight: true,
    },
    {
      aspect: "Facilidade de debug",
      single: "Dif√≠cil (tudo misturado)",
      multi: "F√°cil (isolar o agente)",
    },
  ]}
/>

**Exemplo concreto:** Em um projeto grande, depois de ~40 intera√ß√µes com agente √∫nico, comecei a notar que o Claude "esquecia" decis√µes anteriores. Com sub-agents, cheguei a 150+ intera√ß√µes na mesma sess√£o sem degrada√ß√£o percept√≠vel.

O motivo √© simples: cada sub-agent processa sua tarefa em isolamento, e s√≥ o **resultado condensado** volta pro contexto principal. √â como ter uma equipe que te entrega relat√≥rios executivos ao inv√©s de te incluir em todas as reuni√µes.

## Por que isso importa: o princ√≠pio da responsabilidade √∫nica

Se voc√™ trabalha com arquitetura de software, conhece o SRP (Single Responsibility Principle). Um m√≥dulo deve ter apenas um motivo para mudar.

O mesmo princ√≠pio se aplica a agentes de IA:

<ComparisonTable
  title="SRP Aplicado a Agentes de IA"
  columns={[
    { header: "Caracter√≠stica", key: "char" },
    { header: "‚ùå Agente Monol√≠tico", key: "mono", align: "center" },
    { header: "‚úÖ Sub-Agents Especializados", key: "micro", align: "center" },
  ]}
  data={[
    {
      char: "Instru√ß√µes",
      mono: "Conflitantes e gen√©ricas",
      micro: "Claras e focadas",
    },
    {
      char: "Contexto",
      mono: "Polu√≠do com tudo",
      micro: "Limpo e relevante",
    },
    {
      char: "Output",
      mono: "Inconsistente",
      micro: "Previs√≠vel",
    },
    {
      char: "Debug",
      mono: "Dif√≠cil identificar problema",
      micro: "Isolar agente espec√≠fico",
    },
    {
      char: "Manuten√ß√£o",
      mono: "Mudan√ßa afeta tudo",
      micro: "Mudan√ßa isolada",
    },
  ]}
/>

√â a diferen√ßa entre um monolito e microservi√ßos, mas para IA.

## Quando n√£o usar sub-agents

Sub-agents n√£o s√£o silver bullet. Tem situa√ß√µes onde n√£o fazem sentido:

<ComparisonTable
  title="Quando Usar vs N√£o Usar Sub-Agents"
  columns={[
    { header: "Cen√°rio", key: "scenario" },
    { header: "Recomenda√ß√£o", key: "rec", align: "center" },
    { header: "Motivo", key: "reason" },
  ]}
  data={[
    {
      scenario: "Tarefas simples e √∫nicas",
      rec: "‚ùå N√£o usar",
      reason: "Overhead de invoca√ß√£o n√£o compensa",
    },
    {
      scenario: "Explora√ß√£o inicial",
      rec: "‚ùå N√£o usar",
      reason: "Conversa livre √© mais √∫til",
    },
    {
      scenario: "Contexto muito espec√≠fico do projeto",
      rec: "‚ö†Ô∏è Depende",
      reason: "Pode gastar mais tempo explicando",
    },
    {
      scenario: "Projetos pequenos (<500 LOC)",
      rec: "‚ùå N√£o usar",
      reason: "Over-engineering",
    },
    {
      scenario: "Code reviews frequentes",
      rec: "‚úÖ Usar",
      reason: "Consist√™ncia e completude",
      highlight: true,
    },
    {
      scenario: "Sess√µes longas de desenvolvimento",
      rec: "‚úÖ Usar",
      reason: "Preserva contexto principal",
      highlight: true,
    },
    {
      scenario: "M√∫ltiplas perspectivas necess√°rias",
      rec: "‚úÖ Usar",
      reason: "Especializa√ß√£o > generaliza√ß√£o",
      highlight: true,
    },
    {
      scenario: "Time usando padr√µes compartilhados",
      rec: "‚úÖ Usar",
      reason: "Consist√™ncia entre devs",
    },
  ]}
/>

## Configurando sub-agents no Claude Code

O Claude Code permite configurar sub-agents atrav√©s de arquivos markdown na pasta `.claude/`. Cada arquivo define um agente com suas instru√ß√µes.

### Estrutura b√°sica

<ExecutableCode
  title="Directory Structure for Sub-Agents"
  language="bash"
  code={`tree .claude/

# Create initial structure
mkdir -p .claude
touch .claude/code-reviewer.md
touch .claude/golang-expert.md
touch .claude/doc-writer.md
touch .claude/security-auditor.md`}
  output={`.claude/
‚îú‚îÄ‚îÄ code-reviewer.md
‚îú‚îÄ‚îÄ golang-expert.md
‚îú‚îÄ‚îÄ doc-writer.md
‚îî‚îÄ‚îÄ security-auditor.md

4 files, 0 directories`}
/>

Cada arquivo segue um formato simples:

```markdown
# Code Reviewer

## Role
You are a senior code reviewer specialized in Go and Python.

## Responsibilities
- Identify bugs and edge cases
- Suggest readability improvements
- Verify adherence to project standards
- Point out performance issues

## Guidelines
- Be specific: point out line and file
- Explain the "why" of each suggestion
- Prioritize: critical > important > nice-to-have
- Don't rewrite entire code, suggest targeted changes

## Output Format
For each issue found:
1. Severity (critical/important/suggestion)
2. File and line
3. Identified problem
4. Correction suggestion
5. Justification

## Examples
[good review examples here]
```

### Os agentes que uso no dia a dia

Vou compartilhar os principais sub-agents que configuro em projetos Go/Python.

<ExecutableCode
  title="Sub-Agent: Code Reviewer"
  language="markdown"
  code={`# Code Reviewer

## Role
Code reviewer focused on quality and maintainability.

## Focus Areas
- Race conditions and concurrency issues
- Proper error handling
- Naming and readability
- Cyclomatic complexity
- Missing tests

## What I Don't Do
- Reformat code (leave it to the linter)
- Discuss personal style
- Suggest massive refactorings without context

## Review Checklist
- [ ] Are errors handled, not ignored?
- [ ] Are names descriptive?
- [ ] Do functions have single responsibility?
- [ ] Are there tests for edge cases?
- [ ] Is concurrency safe?

## Output Format
- | Severity | File:Line | Issue | Suggestion |
- |----------|-----------|-------|------------|
- | üî¥ Critical | file.go:42 | ... | ...      |
- | üü° Medium   | file.go:87 | ... | ...      |
- | üü¢ Suggestion| file.go:123 | ... | ...    |
\`\`\``}
  output={`‚úì File .claude/code-reviewer.md created
‚úì Agent available via /code-reviewer`}
/>

<ExecutableCode
  title="Sub-Agent: Golang Expert"
  language="markdown"
  code={`# Golang Expert

## Role
Go specialist focused on idiomatic and performant code.

## Expertise
- Concurrency patterns (goroutines, channels, sync)
- Idiomatic error handling
- Interface design
- Performance optimization
- Standard library

## Guidelines
- Prefer stdlib when possible
- Channels for communication, mutexes for state
- Errors are values, treat them as such
- Small and focused interfaces
- Context in all I/O operations

## Anti-patterns I Flag
- init() with side effects
- Goroutine leaks
- Race conditions
- Panic in library code
- Interface pollution

## Code Patterns I Recommend
\`\`\`go
// ‚úÖ Idiomatic error handling
if err != nil {
    return fmt.Errorf("failed to process: %w", err)
}

// ‚úÖ Context propagation
func DoWork(ctx context.Context) error {
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
        // work
    }
}

// ‚úÖ Graceful shutdown
g, ctx := errgroup.WithContext(ctx)
g.Go(func() error { return worker(ctx) })
\`\`\``}
  output={`‚úì File .claude/golang-expert.md created
‚úì Agent available via /golang-expert`}
/>

<ExecutableCode
  title="Sub-Agent: Security Auditor"
  language="markdown"
  code={`# Security Auditor

## Role
Security analyst focused on code and architecture.

## Focus Areas
- Input validation
- Authentication/Authorization
- Secrets management
- SQL injection
- XSS/CSRF
- Dependency vulnerabilities

## Severity Classification
- | Level | Description | SLA |
- |-------|-------------|-----|
- | üî¥ CRITICAL | Immediate exploitation possible | Fix in 24h |
- | üü† HIGH | Significant risk | Fix in 1 week |
- | üü° MEDIUM | Moderate risk | Plan for sprint |
- | üü¢ LOW | Security improvement | Backlog |

## Output Format
### Finding #1: [Title]
- **Severity:** üî¥ CRITICAL
- **CWE:** CWE-89 (SQL Injection)
- **File:** user_repository.go:45
- **Description:** SQL query built with concatenation
- **PoC:** \`' OR '1'='1\`
- **Remediation:** Use prepared statements
- **Reference:** OWASP Top 10 A03:2021`}
  output={`‚úì File .claude/security-auditor.md created
‚úì Agent available via /security-auditor`}
/>

<ExecutableCode
  title="Sub-Agent: Doc Writer"
  language="markdown"
  code={`# Documentation Writer

## Role
Technical writer specialized in engineering documentation.

## Document Types
- ADRs (Architecture Decision Records)
- READMEs
- API documentation
- Runbooks
- Postmortems

## ADR Template
When asked to create an ADR, use this format:

# ADR-XXXX: [Descriptive Title]

## Status
[proposed | accepted | deprecated | superseded by ADR-XXXX]

## Context
[Why are we making this decision? What problem are we solving?]

## Decision
[What did we decide to do?]

## Consequences
### Positive
- ...

### Negative
- ...

### Risks
- ...

## Alternatives Considered
1. **[Alternative 1]**: [Why we didn't choose it]
2. **[Alternative 2]**: [Why we didn't choose it]

## References
- [Relevant links]

## Writing Style
- Straight to the point
- Concrete examples
- Avoid unnecessary jargon
- Links to references`}
  output={`‚úì File .claude/doc-writer.md created
‚úì Agent available via /doc-writer`}
/>

## Exemplo pr√°tico: workflow de code review

Vou mostrar como uso sub-agents em um workflow real de code review.

**Cen√°rio:** Recebi um PR com uma nova feature de processamento de pagamentos.

<MermaidDiagram
  title="Workflow de Code Review com Sub-Agents"
  chart={`
sequenceDiagram
    autonumber
    participant Dev as Developer
    participant Main as Contexto Principal
    participant CR as /code-reviewer
    participant SA as /security-auditor
    participant GE as /golang-expert
    participant PR as Pull Request

    Dev->>Main: Revisar PR #123 de pagamentos
    
    Note over Main: Delega para especialistas

    Main->>CR: An√°lise geral de qualidade
    activate CR
    Note over CR: Contexto isolado<br/>~15K tokens
    CR->>CR: Analisa error handling
    CR->>CR: Verifica testes
    CR->>CR: Checa naming
    CR-->>Main: üìã 3 issues (1 cr√≠tica)
    deactivate CR

    Main->>SA: Verificar seguran√ßa
    activate SA
    Note over SA: Contexto isolado<br/>~20K tokens
    SA->>SA: Scan de vulnerabilidades
    SA->>SA: Valida input sanitization
    SA->>SA: Checa secrets exposure
    SA-->>Main: üîí 1 finding m√©dio
    deactivate SA

    Main->>GE: Otimizar concorr√™ncia
    activate GE
    Note over GE: Contexto isolado<br/>~12K tokens
    GE->>GE: Analisa goroutine usage
    GE->>GE: Verifica race conditions
    GE->>GE: Sugere errgroup
    GE-->>Main: ‚ö° 2 otimiza√ß√µes
    deactivate GE

    Note over Main: Contexto principal<br/>permanece em ~60K tokens<br/>(n√£o acumulou os 47K dos sub-agents)

    Main->>Dev: Review consolidado
    Dev->>PR: Aplica corre√ß√µes
    Dev->>Main: Re-review r√°pido
    Main-->>Dev: ‚úÖ LGTM
  `}
/>

**Passo 1: Review geral**

<ExecutableCode
  title="Step 1: General Code Review"
  language="bash"
  code={`/code-reviewer analyze PR #123

Special focus on:
- Error handling
- Edge cases
- Tests`}
  output={`üîç Analyzing PR #123...

üìã Issues found:

| Severity | File:Line | Issue | Suggestion |
|----------|-----------|-------|------------|
| üî¥ Critical | payment.go:156 | Untreated error in transaction | Add defer/rollback |
| üü° Medium | validator.go:42 | Missing edge case validation | Validate negative values |
| üü¢ Suggestion | handler.go:89 | Missing timeout test | Add test case |

‚úÖ 3 issues identified (1 critical, 1 medium, 1 suggestion)`}
/>

O code-reviewer retorna uma lista estruturada de issues, priorizadas por severidade.

**Passo 2: An√°lise de seguran√ßa**

<ExecutableCode
  title="Step 2: Security Audit"
  language="bash"
  code={`/security-auditor check payment code

Context: This code processes financial transactions
and interacts with Stripe external API.`}
  output={`üîí Scanning payment module...

### Finding #1: Stripe API Key in logs
- **Severity:** üü† HIGH
- **CWE:** CWE-532 (Information Exposure Through Log Files)
- **File:** payment_service.go:234
- **Description:** Stripe API key being logged in error case
- **Remediation:** Sanitize logs before writing, mask secrets
- **Reference:** OWASP Top 10 A09:2021

### Finding #2: Insufficient input validation
- **Severity:** üü° MEDIUM
- **File:** payment_handler.go:67
- **Description:** Amount accepts negative values
- **Remediation:** Add validation: amount > 0

‚úÖ 2 vulnerabilities found (1 HIGH, 1 MEDIUM)`}
/>

O security-auditor foca em vulnerabilidades espec√≠ficas: valida√ß√£o de input, secrets, logging de dados sens√≠veis.

**Passo 3: Verifica√ß√£o Go-espec√≠fica**

<ExecutableCode
  title="Step 3: Go Expert - Concurrency Review"
  language="bash"
  code={`/golang-expert review concurrency patterns
in file payment_processor.go

Specifically:
- Worker pool implementation
- Channel usage
- Error propagation`}
  output={`‚ö° Analyzing concurrency patterns...

### Issue #1: Goroutine Leak
\`\`\`go
// ‚ùå Problem (line 145-150)
for _, payment := range payments {
    go processPayment(payment) // leak: no wait group
}

// ‚úÖ Suggestion: use errgroup
g, ctx := errgroup.WithContext(ctx)
for _, payment := range payments {
    p := payment
    g.Go(func() error {
        return processPayment(ctx, p)
    })
}
if err := g.Wait(); err != nil {
    return fmt.Errorf("payment processing failed: %w", err)
}
\`\`\`

### Issue #2: Unbuffered channel
- **Line:** 89
- **Problem:** Potential deadlock in error path
- **Suggestion:** Use buffered channel or context cancellation

‚úÖ 2 optimizations suggested
üìà Estimated reduction: 40% fewer goroutines, robust error handling`}
/>

O golang-expert encontra um potencial goroutine leak e sugere usar errgroup.

**Resultado:** Tr√™s perspectivas diferentes, cada uma focada no que faz melhor. E o mais importante: **meu contexto principal n√£o saturou** com os detalhes de cada an√°lise - recebi apenas os resultados condensados.

<ComparisonTable
  title="Economia de Contexto no Workflow"
  columns={[
    { header: "Etapa", key: "step" },
    { header: "Contexto Usado", key: "used", align: "right" },
    { header: "Retornado ao Principal", key: "returned", align: "right" },
    { header: "Economia", key: "saved", align: "right" },
  ]}
  data={[
    {
      step: "Code Review",
      used: "~15K tokens",
      returned: "~2K tokens",
      saved: "87%",
      highlight: true,
    },
    {
      step: "Security Audit",
      used: "~20K tokens",
      returned: "~1.5K tokens",
      saved: "92%",
    },
    {
      step: "Go Expert Review",
      used: "~12K tokens",
      returned: "~1K tokens",
      saved: "92%",
      highlight: true,
    },
    {
      step: "TOTAL",
      used: "~47K tokens",
      returned: "~4.5K tokens",
      saved: "90%",
    },
  ]}
/>

## Arquitetura de sub-agents: design patterns

Depois de usar sub-agents por alguns meses, identifiquei alguns patterns que funcionam bem.

### Pattern 1: Orquestrador + Especialistas

<MermaidDiagram
  title="Pattern: Orquestrador + Especialistas"
  chart={`
flowchart TB
    User[Usu√°rio] --> Orch["Orquestrador<br/>Contexto Principal"]

    Orch --> Decision{Tipo de tarefa?}

    Decision -->|Code| CR["code-reviewer"]
    Decision -->|Security| SA["security-auditor"]
    Decision -->|Docs| DW["doc-writer"]
    Decision -->|Performance| PE["perf-engineer"]
    Decision -->|Go espec√≠fico| GE["golang-expert"]

    CR --> Results["Resultados<br/>Consolidados"]
    SA --> Results
    DW --> Results
    PE --> Results
    GE --> Results

    Results --> Orch
    Orch --> User

    style Orch fill:#1e40af,stroke:#3b82f6,color:#dbeafe
    style CR fill:#166534,stroke:#22c55e,color:#dcfce7
    style SA fill:#991b1b,stroke:#ef4444,color:#fee2e2
    style DW fill:#78350f,stroke:#f59e0b,color:#fef3c7
    style PE fill:#581c87,stroke:#a855f7,color:#e9d5ff
    style GE fill:#0f766e,stroke:#14b8a6,color:#ccfbf1
  `}
/>

### Pattern 2: Pipeline de Valida√ß√£o

<MermaidDiagram
  title="Pattern: Pipeline de Valida√ß√£o"
  chart={`
flowchart LR
    Code[C√≥digo] --> CR["code-reviewer"]
    CR -->|Pass| SA["security-auditor"]
    CR -->|Fail| Fix1[Corre√ß√µes]
    Fix1 --> CR

    SA -->|Pass| PE["perf-engineer"]
    SA -->|Fail| Fix2[Corre√ß√µes]
    Fix2 --> SA

    PE -->|Pass| Ready["Ready to Merge"]
    PE -->|Fail| Fix3[Otimiza√ß√µes]
    Fix3 --> PE

    style Ready fill:#14532d,stroke:#22c55e,color:#dcfce7
    style CR fill:#1e3a8a,stroke:#3b82f6,color:#dbeafe
    style SA fill:#991b1b,stroke:#ef4444,color:#fee2e2
    style PE fill:#581c87,stroke:#a855f7,color:#e9d5ff
  `}
/>

### Pattern 3: Especialistas em Paralelo

Quando as an√°lises s√£o independentes, rode em paralelo:

<ExecutableCode
  title="Pattern 3: Parallel Agent Execution"
  language="bash"
  code={`# Parallel execution (if your setup allows)
/code-reviewer analyze payment.go &
/security-auditor scan payment.go &
/golang-expert optimize payment.go &

# Wait for all to complete
wait

# Consolidate results`}
  output={`üöÄ Starting parallel analyses of payment.go...

[1] code-reviewer started (PID 12345)
[2] security-auditor started (PID 12346)
[3] golang-expert started (PID 12347)

‚è≥ Waiting for completion...

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

[1] ‚úÖ code-reviewer completed (2.3s)
üìã 2 issues found (1 medium, 1 suggestion)

[2] ‚úÖ security-auditor completed (1.8s)
üîí 1 HIGH vulnerability found

[3] ‚úÖ golang-expert completed (3.1s)
‚ö° 3 optimizations suggested

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìä Consolidated Results:

Code Quality:
  - üü° payment.go:89 - Inconsistent error wrapping
  - üü¢ payment.go:156 - Add context to log

Security:
  - üî¥ payment.go:234 - API key exposed in logs

Performance:
  - ‚ö° payment.go:45 - Use sync.Pool to reduce allocations
  - ‚ö° payment.go:127 - Cache repetitive validations
  - ‚ö° payment.go:189 - Batch processing for multiple payments

‚úÖ Total: 6 findings in 3.1s (vs ~7s sequential)
üìà Gain: 55% faster with parallel execution`}
/>

## Armadilhas comuns

**1. Too generic agents**

```markdown
# ‚ùå Bad: General Helper
You help with anything programming related.
```

This is basically having no agent at all. The more specific, the better.

**2. Conflicting instructions**

```markdown
# ‚ùå Bad: Mixed Responsibilities
- Review code
- Write tests
- Optimize performance
- Document APIs
```

Each of these should be a separate agent.

**3. Lack of examples**

Agents learn a lot from examples. An agent with zero examples produces inconsistent output.

```markdown
## ‚úÖ Good: With examples

### Example Output

- | Severity | File:Line | Issue | Suggestion |
- |----------|-----------|-------|------------|
- | üî¥ Critical | auth.go:42 | SQL injection via concatenation | Use prepared statements |

### Anti-Example (don't do this)

"The code has some security issues you should look at."
```

**4. Not iterating**

Your first agent draft will be bad. The second too. Iterate based on real output until the agent consistently produces what you expect.

## M√©tricas que observo

Como saber se sub-agents est√£o funcionando? Algumas m√©tricas que acompanho:

<ComparisonTable
  title="M√©tricas de Produtividade com Sub-Agents"
  columns={[
    { header: "M√©trica", key: "metric" },
    { header: "Antes", key: "before", align: "center" },
    { header: "Depois", key: "after", align: "center" },
    { header: "Melhoria", key: "improvement", align: "center" },
  ]}
  data={[
    {
      metric: "Tempo m√©dio de review (PR m√©dio)",
      before: "~2h",
      after: "~30min",
      improvement: "75% ‚¨áÔ∏è",
      highlight: true,
    },
    {
      metric: "Bugs escapados para prod/m√™s",
      before: "~5",
      after: "~1",
      improvement: "80% ‚¨áÔ∏è",
      highlight: true,
    },
    {
      metric: "Intera√ß√µes √∫teis por sess√£o",
      before: "~40",
      after: "~150+",
      improvement: "275% ‚¨ÜÔ∏è",
    },
    {
      metric: "Retrabalho em PRs",
      before: "~3 rounds",
      after: "~1 round",
      improvement: "66% ‚¨áÔ∏è",
    },
    {
      metric: "Consist√™ncia de docs",
      before: "Vari√°vel",
      after: "Padronizada",
      improvement: "‚úÖ",
    },
  ]}
/>

## O ecossistema: awesome-claude-code-subagents

Se voc√™ n√£o quer criar tudo do zero, existe um reposit√≥rio da comunidade com sub-agents prontos: [VoltAgent/awesome-claude-code-subagents](https://github.com/VoltAgent/awesome-claude-code-subagents).

**126 agentes especializados**, prontos para usar.

<MermaidDiagram
  title="Ecossistema de 126 Sub-Agents Dispon√≠veis"
  chart={`
mindmap
  root((126 Agentes))
    Core Dev 5
      api-designer
      backend-developer
      frontend-developer
      fullstack-developer
      mobile-developer
    Languages 20
      golang-pro
      python-pro
      typescript-pro
      rust-engineer
      java-architect
      cpp-pro
      javascript-pro
      react-specialist
      ...16 mais
    Infrastructure 12
      cloud-architect
      kubernetes-specialist
      terraform-engineer
      devops-engineer
      database-administrator
      ...7 mais
    Quality & Security 13
      code-reviewer
      security-auditor
      penetration-tester
      chaos-engineer
      performance-engineer
      ...8 mais
    Data & AI 10
      ai-engineer
      llm-architect
      mlops-engineer
      data-scientist
      nlp-engineer
      ...5 mais
    Dev Experience 11
      dx-optimizer
      git-workflow-manager
      refactoring-specialist
      prompt-engineer
      ...7 mais
    Business 10
      product-manager
      business-analyst
      sales-engineer
      legal-advisor
      ...6 mais
    Meta 9
      multi-agent-coordinator
      workflow-orchestrator
      context-manager
      ...6 mais
  `}
/>

### Categorias principais

O reposit√≥rio organiza os agentes em 10 categorias:

<ComparisonTable
  title="Categorias de Agentes Dispon√≠veis"
  columns={[
    { header: "Categoria", key: "category" },
    { header: "Qtd", key: "count", align: "center" },
    { header: "Exemplos", key: "examples" },
    { header: "Caso de Uso", key: "usecase" },
  ]}
  data={[
    {
      category: "Core Development",
      count: "5",
      examples: "frontend-developer, backend-developer, fullstack-developer",
      usecase: "Desenvolvimento end-to-end de features",
    },
    {
      category: "Language Specialists",
      count: "20",
      examples: "golang-pro, python-pro, rust-engineer, react-specialist",
      usecase: "Expertise espec√≠fica por linguagem/framework",
      highlight: true,
    },
    {
      category: "Infrastructure",
      count: "12",
      examples: "cloud-architect, kubernetes-specialist, terraform-engineer",
      usecase: "Deploy, infra-as-code, cloud",
    },
    {
      category: "Quality & Security",
      count: "13",
      examples: "code-reviewer, security-auditor, penetration-tester",
      usecase: "Code review, security audit, testing",
      highlight: true,
    },
    {
      category: "Data & AI",
      count: "10",
      examples: "llm-architect, mlops-engineer, data-scientist",
      usecase: "ML/AI pipelines, analytics",
    },
    {
      category: "Developer Experience",
      count: "11",
      examples: "dx-optimizer, git-workflow-manager, prompt-engineer",
      usecase: "Melhoria de produtividade dev",
    },
    {
      category: "Specialized Domains",
      count: "10",
      examples: "blockchain-developer, fintech-engineer, game-developer",
      usecase: "Dom√≠nios nichados espec√≠ficos",
    },
    {
      category: "Business & Product",
      count: "10",
      examples: "product-manager, business-analyst, legal-advisor",
      usecase: "Decis√µes de produto e neg√≥cio",
    },
    {
      category: "Meta & Orchestration",
      count: "9",
      examples: "multi-agent-coordinator, workflow-orchestrator",
      usecase: "Coordenar outros agentes",
      highlight: true,
    },
    {
      category: "Operations & Deployment",
      count: "8",
      examples: "deployment-engineer, incident-responder, sre-engineer",
      usecase: "Ops, monitoring, deploys",
    },
  ]}
/>

### Agentes que uso frequentemente

Dos 126 dispon√≠veis, alguns se tornaram essenciais no meu workflow:

<ExecutableCode
  title="Installing Agents from Repository"
  language="bash"
  code={`# Clone the repository
git clone https://github.com/VoltAgent/awesome-claude-code-subagents.git
cd awesome-claude-code-subagents

# Copy the agents you want to your project
cp agents/code-reviewer.md ~/.claude/
cp agents/golang-pro.md ~/.claude/
cp agents/security-auditor.md ~/.claude/
cp agents/technical-writer.md ~/.claude/
cp agents/devops-engineer.md ~/.claude/

# Verify they were installed
ls -la ~/.claude/`}
  output={`Cloning into 'awesome-claude-code-subagents'...
remote: Enumerating objects: 450, done.
remote: Counting objects: 100% (450/450), done.
remote: Compressing objects: 100% (320/320), done.
remote: Total 450 (delta 180), reused 380 (delta 120)
Receiving objects: 100% (450/450), 1.2 MiB | 2.5 MiB/s, done.

total 40
-rw-r--r-- 1 user user 5234 Jan 01 10:30 code-reviewer.md
-rw-r--r-- 1 user user 4821 Jan 01 10:30 golang-pro.md
-rw-r--r-- 1 user user 6102 Jan 01 10:30 security-auditor.md
-rw-r--r-- 1 user user 3945 Jan 01 10:30 technical-writer.md
-rw-r--r-- 1 user user 5567 Jan 01 10:30 devops-engineer.md

‚úÖ 5 agents installed and ready to use!`}
/>

**Top 10 agentes que mais uso:**

1. **code-reviewer** - Review autom√°tico de PRs
2. **golang-pro** - Expert em Go idiom√°tico
3. **security-auditor** - OWASP top 10, CVEs
4. **technical-writer** - Docs, ADRs, READMEs
5. **devops-engineer** - CI/CD, Docker, K8s
6. **refactoring-specialist** - Limpeza de c√≥digo t√©cnico debt
7. **database-optimizer** - Query optimization, indexes
8. **performance-engineer** - Profiling, bottlenecks
9. **git-workflow-manager** - Branching, merging, conflicts
10. **prompt-engineer** - Otimizar prompts de outros agentes

### Agentes Meta: orquestrando outros agentes

Uma categoria interessante s√£o os **Meta & Orchestration agents** - agentes que coordenam outros agentes:

<ExecutableCode
  title="Using Multi-Agent Coordinator"
  language="bash"
  code={`/multi-agent-coordinator execute full review pipeline

Tasks:
1. Code review (quality)
2. Security audit
3. Performance analysis
4. Documentation check

Run in parallel where possible.`}
  output={`üé≠ Multi-Agent Coordinator starting...

üìã Pipeline defined:
  ‚îú‚îÄ Parallel: code-reviewer + security-auditor + performance-engineer
  ‚îî‚îÄ Sequential: technical-writer (after results)

üöÄ Executing parallel phase...

[‚ö° Phase 1 - Parallel] (3.2s)
  ‚úÖ code-reviewer: 3 issues found
  ‚úÖ security-auditor: 1 MEDIUM vulnerability
  ‚úÖ performance-engineer: 2 optimizations suggested

[üìù Phase 2 - Documentation] (1.8s)
  ‚úÖ technical-writer: Documentation updated with findings

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìä Consolidated Summary:

Quality: 3 issues (1 critical)
Security: 1 medium vulnerability
Performance: 2 optimizations
Docs: README.md + SECURITY.md updated

‚úÖ Pipeline completed in 5.0s
üìÅ Report saved at: review-report-2025-01-01.md`}
/>

O `multi-agent-coordinator` decide:
- Quais agentes invocar
- Ordem de execu√ß√£o (paralelo vs sequencial)
- Como consolidar resultados
- Onde h√° depend√™ncias entre agentes

√â como ter um "orquestrador de orquestradores".

### Customiza√ß√£o e extens√£o

Os agentes do reposit√≥rio s√£o **pontos de partida**, n√£o solu√ß√µes finais. Voc√™ deve adapt√°-los ao seu contexto:

```markdown
# Example: Customizing code-reviewer for your team

# Code Reviewer - Acme Corp Edition

## Role
Reviewer following Acme Corp standards.

## Our Standards
- Always use our internal logging lib: `acme/log`
- Name tests as `TestXxx_Scenario`
- Max 15 lines per function
- Mandatory comments on public functions

## Specific Checks
- [ ] Uses acme/log instead of log.Printf?
- [ ] Configs come from config.yaml, not hardcoded?
- [ ] Secrets never in plain text?
- [ ] DB migrations have rollback?

## Our Tech Stack
- Go 1.21+
- PostgreSQL 15
- Kubernetes 1.28
- gRPC + Protocol Buffers

[rest of agent...]
```

### Vale a pena usar agentes prontos?

<ComparisonTable
  title="Pr√≥s e Contras de Usar Agentes Prontos"
  columns={[
    { header: "Aspecto", key: "aspect" },
    { header: "‚úÖ Pr√≥s", key: "pros" },
    { header: "‚ùå Contras", key: "cons" },
  ]}
  data={[
    {
      aspect: "Tempo de setup",
      pros: "Minutos (vs dias criando do zero)",
      cons: "Precisa revisar/customizar",
    },
    {
      aspect: "Qualidade",
      pros: "Comunidade testou e iterou",
      cons: "Pode n√£o se encaixar 100% no seu caso",
    },
    {
      aspect: "Manuten√ß√£o",
      pros: "Updates da comunidade",
      cons: "Voc√™ precisa fazer merge de updates",
    },
    {
      aspect: "Aprendizado",
      pros: "Veja como outros resolveram",
      cons: "Pode ser tentador n√£o entender o agente",
    },
    {
      aspect: "Consist√™ncia",
      pros: "Padr√µes estabelecidos",
      cons: "Seu time pode ter padr√µes pr√≥prios",
    },
  ]}
/>

**Minha recomenda√ß√£o:** Comece com agentes prontos, use por 1-2 semanas, anote o que funciona e o que n√£o funciona, ent√£o customize. N√£o tente criar tudo do zero - voc√™ vai reinventar a roda.

## Pr√≥ximos passos

Se voc√™ quer come√ßar com sub-agents:

**1. Identifique tarefas repetitivas**
O que voc√™ faz toda semana que poderia ser delegado?

**2. Comece com um agente**
N√£o tente criar 10 de uma vez. Comece com o code-reviewer ou equivalente.

**3. Itere baseado em uso real**
Use por uma semana, anote o que funciona e o que n√£o funciona, ajuste.

**4. Expanda gradualmente**
Adicione novos agentes conforme identificar necessidades.

---

## Refer√™ncias

- [VoltAgent/awesome-claude-code-subagents](https://github.com/VoltAgent/awesome-claude-code-subagents) - Cole√ß√£o de sub-agents prontos
- [Claude Code Documentation](https://docs.anthropic.com/en/docs/claude-code) - Documenta√ß√£o oficial
- [Architecture Decision Records](https://adr.github.io/) - Padr√£o de ADRs
- [Single Responsibility Principle](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html) - Uncle Bob sobre SRP

---

*Usa sub-agents no seu workflow? Tem algum agente customizado que funciona bem? Me conta no [X](https://x.com/orlandocbit)!*
